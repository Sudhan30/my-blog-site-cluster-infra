apiVersion: v1
kind: ConfigMap
metadata:
  name: job-fit-backend-code
  namespace: web
data:
  main.py: |
    from fastapi import FastAPI, HTTPException
    from pydantic import BaseModel
    import requests
    import hashlib
    import json
    from fastapi.middleware.cors import CORSMiddleware
    import os

    app = FastAPI()

    # Enable CORS for the frontend
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    CACHE = {}
    OLLAMA_HOST = os.getenv("OLLAMA_HOST", "http://ollama-service:11434")

    class FitRequest(BaseModel):
        resume: str = None
        preferences: dict = None
        job: str

    def cache_key(data: FitRequest):
        resume_part = data.resume[:50] if data.resume else "no-resume" 
        job_part = data.job[:50] 
        raw = resume_part + json.dumps(data.preferences or {}) + data.job
        return hashlib.sha256(raw.encode()).hexdigest()

    PROMPT_TEMPLATE = """
    You are a job fit evaluator for a professional portfolio website.
    Your task is to evaluate how well the portfolio owner fits a job.

    Be objective and evidence based.
    Do not assume skills that are not written.
    If data is missing, say unknown.

    Resume:
    {resume}

    Preferences:
    {preferences}

    Job Description:
    {job}

    TASK
    Compare the resume and preferences to the job.
    Evaluate skills match, experience level match, domain match, role and career alignment.

    SCORING
    Give a score from 0 to 100.
    90-100: strong fit
    70-89: good fit
    50-69: partial fit
    <50: weak fit

    OUTPUT
    Return ONLY valid JSON.
    {{
    "fit_score": 0,
    "fit_level": "",
    "aligned_areas": [],
    "gaps": [],
    "summary": "",
    "verdict": ""
    }}

    Keep summary under 80 words.
    """

    @app.post("/job-fit")
    def job_fit(req: FitRequest):
        print("=" * 60)
        print("[INPUT] Received job-fit request")
        print(f"[INPUT] Resume length: {len(req.resume) if req.resume else 0} chars")
        print(f"[INPUT] Job length: {len(req.job) if req.job else 0} chars")
        print(f"[INPUT] Preferences: {json.dumps(req.preferences or {}, indent=2)}")
        print(f"[INPUT] Job (first 500 chars): {req.job[:500] if req.job else 'None'}...")
        print("=" * 60)

        if not req.resume:
           print("[ERROR] No resume provided")
           return {"error": "Resume text is required"}

        key = cache_key(req)
        if key in CACHE:
            print(f"[CACHE] Hit for key: {key}")
            print(f"[CACHE] Returning cached result: {json.dumps(CACHE[key], indent=2)}")
            return CACHE[key]

        prompt = PROMPT_TEMPLATE.format(
            resume=req.resume,
            preferences=json.dumps(req.preferences or {}),
            job=req.job
        )

        print(f"[PROMPT] Total prompt length: {len(prompt)} chars")

        try:
            print(f"[OLLAMA] Sending request to {OLLAMA_HOST}...")
            r = requests.post(
                f"{OLLAMA_HOST}/api/generate",
                json={
                    "model": "gemma:7b",
                    "prompt": prompt,
                    "stream": False,
                    "temperature": 0.3,
                    "format": "json"
                },
                timeout=120
            )
            r.raise_for_status()
            text = r.json().get("response", "")
            print(f"[OLLAMA] Response status: {r.status_code}")
            print(f"[OLLAMA] Raw response length: {len(text)} chars")
            print(f"[OLLAMA] Raw response: {text}")

            try:
                parsed = json.loads(text)
                print(f"[PARSE] Successfully parsed JSON")
            except json.JSONDecodeError as je:
                print(f"[PARSE] JSON decode error: {je}")
                start = text.find("{")
                end = text.rfind("}") + 1
                if start != -1 and end != -1:
                     parsed = json.loads(text[start:end])
                     print(f"[PARSE] Extracted JSON from position {start} to {end}")
                else:
                     parsed = {"error": "invalid_json", "raw": text}
                     print(f"[PARSE] Could not extract JSON, returning error")

            print(f"[OUTPUT] Final response: {json.dumps(parsed, indent=2)}")
            print("=" * 60)

            CACHE[key] = parsed
            return parsed

        except Exception as e:
            print(f"[ERROR] Exception: {type(e).__name__}: {e}")
            print("=" * 60)
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/health")
    def health():
        return {"status": "ok"}
