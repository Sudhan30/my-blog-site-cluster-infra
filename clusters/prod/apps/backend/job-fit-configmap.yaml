apiVersion: v1
kind: ConfigMap
metadata:
  name: job-fit-backend-code
  namespace: web
data:
  main.py: |
    from fastapi import FastAPI, HTTPException
    from pydantic import BaseModel
    import requests
    import hashlib
    import json
    from fastapi.middleware.cors import CORSMiddleware
    import os
    from pathlib import Path

    app = FastAPI()

    # Enable CORS for the frontend
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    CACHE = {}
    OLLAMA_HOST = os.getenv("OLLAMA_HOST", "http://ollama-service:11434")
    PRIVATE_DATA_PATH = Path(os.getenv("PRIVATE_DATA_PATH", "/app/private"))

    # Load resume and preferences from server files (not from request)
    def load_resume():
        """Load resume from PDF, DOCX, or TXT file on server"""
        resume_path = PRIVATE_DATA_PATH / "resume"

        # Try PDF first
        pdf_path = resume_path.with_suffix(".pdf")
        if pdf_path.exists():
            try:
                import PyPDF2
                with open(pdf_path, "rb") as f:
                    reader = PyPDF2.PdfReader(f)
                    text = ""
                    for page in reader.pages:
                        text += page.extract_text() + "\n"
                print(f"[RESUME] Loaded from PDF: {pdf_path}")
                return text.strip()
            except Exception as e:
                print(f"[RESUME] Error reading PDF: {e}")

        # Try DOCX
        docx_path = resume_path.with_suffix(".docx")
        if docx_path.exists():
            try:
                from docx import Document
                doc = Document(docx_path)
                text = "\n".join([para.text for para in doc.paragraphs])
                print(f"[RESUME] Loaded from DOCX: {docx_path}")
                return text.strip()
            except Exception as e:
                print(f"[RESUME] Error reading DOCX: {e}")

        # Try plain text
        txt_path = resume_path.with_suffix(".txt")
        if txt_path.exists():
            text = txt_path.read_text()
            print(f"[RESUME] Loaded from TXT: {txt_path}")
            return text.strip()

        print(f"[RESUME] No resume file found in {PRIVATE_DATA_PATH}")
        return None

    def load_preferences():
        """Load preferences from JSON file on server"""
        prefs_path = PRIVATE_DATA_PATH / "preferences.json"
        if prefs_path.exists():
            try:
                prefs = json.loads(prefs_path.read_text())
                print(f"[PREFS] Loaded from: {prefs_path}")
                return prefs
            except Exception as e:
                print(f"[PREFS] Error reading preferences: {e}")
        print(f"[PREFS] No preferences file found at {prefs_path}")
        return {}

    # Cache the loaded data
    _resume_cache = None
    _prefs_cache = None

    def get_resume():
        global _resume_cache
        if _resume_cache is None:
            _resume_cache = load_resume()
        return _resume_cache

    def get_preferences():
        global _prefs_cache
        if _prefs_cache is None:
            _prefs_cache = load_preferences()
        return _prefs_cache

    class FitRequest(BaseModel):
        job: str  # Only job description is required from frontend

    def cache_key(job: str, resume: str, preferences: dict):
        job_part = job[:100] if job else ""
        resume_part = resume[:100] if resume else ""
        raw = job_part + resume_part + json.dumps(preferences or {})
        return hashlib.sha256(raw.encode()).hexdigest()

    PROMPT_TEMPLATE = """
    You are a job fit evaluator for a professional portfolio website.
    Your task is to evaluate how well the portfolio owner fits a job.

    Be objective and evidence based.
    Do not assume skills that are not written.
    If data is missing, say unknown.

    Resume:
    {resume}

    Preferences:
    {preferences}

    Job Description:
    {job}

    TASK
    Compare the resume and preferences to the job.
    Evaluate skills match, experience level match, domain match, role and career alignment.

    SCORING
    Give a score from 0 to 100.
    90-100: strong fit
    70-89: good fit
    50-69: partial fit
    <50: weak fit

    OUTPUT
    Return ONLY valid JSON.
    {{
    "fit_score": 0,
    "fit_level": "",
    "aligned_areas": [],
    "gaps": [],
    "summary": "",
    "verdict": ""
    }}

    Keep summary under 80 words.
    """

    @app.get("/reload")
    def reload_data():
        """Reload resume and preferences from files"""
        global _resume_cache, _prefs_cache
        _resume_cache = None
        _prefs_cache = None
        resume = get_resume()
        prefs = get_preferences()
        return {
            "status": "reloaded",
            "resume_loaded": resume is not None,
            "resume_length": len(resume) if resume else 0,
            "preferences_loaded": bool(prefs)
        }

    @app.post("/job-fit")
    def job_fit(req: FitRequest):
        print("=" * 60)
        print("[INPUT] Received job-fit request")

        # Load resume and preferences from server files
        resume = get_resume()
        preferences = get_preferences()

        print(f"[INPUT] Resume length: {len(resume) if resume else 0} chars")
        print(f"[INPUT] Job length: {len(req.job) if req.job else 0} chars")
        print(f"[INPUT] Preferences: {json.dumps(preferences, indent=2)}")
        print(f"[INPUT] Job (first 500 chars): {req.job[:500] if req.job else 'None'}...")
        print("=" * 60)

        if not resume:
           print("[ERROR] No resume found on server")
           return {"error": "Resume file not found on server. Contact admin."}

        key = cache_key(req.job, resume, preferences)
        if key in CACHE:
            print(f"[CACHE] Hit for key: {key}")
            print(f"[CACHE] Returning cached result: {json.dumps(CACHE[key], indent=2)}")
            return CACHE[key]

        prompt = PROMPT_TEMPLATE.format(
            resume=resume,
            preferences=json.dumps(preferences),
            job=req.job
        )

        print(f"[PROMPT] Total prompt length: {len(prompt)} chars")

        try:
            print(f"[OLLAMA] Sending request to {OLLAMA_HOST}...")
            r = requests.post(
                f"{OLLAMA_HOST}/api/generate",
                json={
                    "model": "phi3:mini",
                    "prompt": prompt,
                    "stream": False,
                    "temperature": 0.3,
                    "format": "json",
                    "keep_alive": "30m"  # Keep model loaded for 30 mins
                },
                timeout=120
            )
            r.raise_for_status()
            text = r.json().get("response", "")
            print(f"[OLLAMA] Response status: {r.status_code}")
            print(f"[OLLAMA] Raw response length: {len(text)} chars")
            print(f"[OLLAMA] Raw response: {text}")

            try:
                parsed = json.loads(text)
                print(f"[PARSE] Successfully parsed JSON")
            except json.JSONDecodeError as je:
                print(f"[PARSE] JSON decode error: {je}")
                start = text.find("{")
                end = text.rfind("}") + 1
                if start != -1 and end != -1:
                     parsed = json.loads(text[start:end])
                     print(f"[PARSE] Extracted JSON from position {start} to {end}")
                else:
                     parsed = {"error": "invalid_json", "raw": text}
                     print(f"[PARSE] Could not extract JSON, returning error")

            print(f"[OUTPUT] Final response: {json.dumps(parsed, indent=2)}")
            print("=" * 60)

            CACHE[key] = parsed
            return parsed

        except Exception as e:
            print(f"[ERROR] Exception: {type(e).__name__}: {e}")
            print("=" * 60)
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/health")
    def health():
        return {"status": "ok"}
